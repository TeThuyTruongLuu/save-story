<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@500;700&display=swap" rel="stylesheet" />
    <title>Qu·∫£n l√Ω Truy·ªán</title>
    <style>
        body {
            font-family: 'Quicksand', sans-serif;
            background-color: #f7f1e3;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
        }
        .container {
            width: 90%;
            max-width: 1000px;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        .toggle-container {
            display: flex;
            justify-content: center;
            background: #f7f1e3;
            border-radius: 50px;
            padding: 5px;
            width: fit-content;
            margin: 0 auto 15px;
        }
        .toggle-btn {
			font-family: 'Quicksand', sans-serif;
            border: none;
            background: none;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: bold;
            color: #6c5ce7;
            cursor: pointer;
            transition: 0.3s ease;
        }
        .toggle-btn:hover {
            color: white;
            background: #6c5ce7;
            border-radius: 50px;
        }
        .toggle-btn.active {
            background: #6c5ce7;
            color: white;
            border-radius: 50px;
        }
        .section {
            display: none;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        .section.active {
            display: block;
        }
        .input-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .flex-row {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            justify-content: space-between;
            padding-bottom: 10px;
            position: relative;
        }
        .flex-row label {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .flex-row input, .flex-row select {
            flex: 1;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 5px;
            margin-left: 10px;
        }
        .flex-row .tag-input {
            flex: 4;
        }
        .suggestions-box {
            position: absolute;
            top: 100%;
            left: 0;
            width: 100%;
            background: white;
            border: 1px solid #ccc;
            max-height: 150px;
            overflow-y: auto;
            display: none;
            z-index: 10;
        }
        .suggestions-box div {
            padding: 8px;
            cursor: pointer;
        }
        .suggestions-box div:hover {
            background: #eee;
        }
        .flex-row .rating-input {
            flex: 1;
            display: flex;
            align-items: center;
        }
        .rating-input input {
            margin-right: 10px;
        }
        .wide-input {
            width: 100%;
        }
        input, select, textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            margin-bottom: 10px;
        }
        button {
            padding: 10px 20px;
            background-color: #6c5ce7;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
        }
        button:hover {
            background: #5a4ae0;
        }
        .button-container {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }
        .table-container {
            max-width: 100%;
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            background: white;
            border-radius: 5px;
            overflow: hidden;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }
        th {
            background-color: #dfe6e9;
            cursor: pointer;
        }
        .delete-btn {
            cursor: pointer;
            color: red;
            font-weight: bold;
        }
        .pagination {
            display: flex;
            justify-content: center;
            margin-top: 15px;
            gap: 5px;
        }
        .pagination button {
            padding: 8px 12px;
            border: 1px solid #6c5ce7;
            background-color: #f7f1e3;
            color: #6c5ce7;
            cursor: pointer;
            border-radius: 5px;
            font-size: 14px;
        }
        .pagination button.active {
            background-color: #6c5ce7;
            color: white;
        }
        .pagination button:hover {
            background-color: #5a4ae0;
            color: white;
        }
        .hidden { display: none; }
		#epub input, #epub textarea, #epub button {
			max-width: 95%;
			display: block;
		}
        @media (max-width: 600px) {
            .table-container {
                max-height: 400px;
                overflow-y: auto;
            }
            table {
                min-width: 600px;
            }
            button { width: 50%; }
            td, th {
                word-wrap: break-word;
                white-space: normal;
            }
            td:nth-child(2) {
                min-width: 120px;
                max-width: 250px;
            }
            td:nth-child(3) {
                min-width: 70px grants;
                max-width: 100px;
            }
            .toggle-container {
                width: 100%;
            }
            .toggle-btn {
                flex: 1;
                font-size: 14px;
                padding: 8px;
            }
            .flex-row {
                flex-direction: column;
            }
            .flex-row label {
                width: 100%;
            }
            .button-container {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>Qu·∫£n l√Ω Truy·ªán</h2>
        <div class="toggle-container">
            <button id="btn-upload" class="toggle-btn active" onclick="toggleSection('upload')">T·∫£i truy·ªán m·ªõi</button>
            <button id="btn-search" class="toggle-btn" onclick="toggleSection('search')">T√¨m truy·ªán</button>
            <button id="btn-epub" class="toggle-btn" onclick="toggleSection('epub')">T·∫£i EPUB</button>
        </div>

        <div id="upload" class="section active">
            <div class="flex-row">
                <label>Nh·∫≠p link truy·ªán: <input type="text" id="storyLink"></label>
                <button onclick="fetchStory()">L∆∞u Truy·ªán</button>
            </div>
            <div class="flex-row">
                <label>Tag b·ªï sung:
                    <input type="text" id="additionalTags" class="tag-input" oninput="suggestTags(event)" autocomplete="off">
                    <div id="tagSuggestions" class="suggestions-box"></div>
                </label>
                <label class="rating-input">ƒê√°nh gi√°: <input type="number" id="rating" min="0" max="10" step="0.5"> / 10</label>
            </div>
            <div class="flex-row">
                <label class="wide-input">Review: <input type="text" id="reviewText"></label>
            </div>
        </div>

        <div id="epub" class="section">
            <h3>T·∫£i Truy·ªán EPUB</h3>
            <input type="text" id="epubUrl" placeholder="D√°n link truy·ªán v√¥ ƒë√¢y nha">
            <textarea id="extra_content" placeholder="Ghi ch√∫ ch∆∞∆°ng..."></textarea>
            <button style ="margin-bottom:10px;" onclick="handleEpubDownload()">T·∫£i EPUB</button>
            <textarea id="log" rows="10" cols="50" readonly></textarea>
        </div>

        <div id="search" class="section">
            <div class="flex-row">
                <label>Ch·ªçn tag mu·ªën: <input type="text" id="desiredTags"></label>
                <label>Ch·ªçn tag kh√¥ng mu·ªën: <input type="text" id="excludedTags"></label>
            </div>
            <div class="flex-row">
                <label>T√°c gi·∫£: <select id="authorSelect"></select></label>
                <label>Editor: <select id="editorSelect"></select></label>
                <label>Tr·∫°ng th√°i: <select id="statusSelect">
                    <option value="">T·∫•t c·∫£</option>
                    <option value="Ho√†n">Ho√†n</option>
                    <option value="ƒêang c·∫≠p nh·∫≠t">ƒêang c·∫≠p nh·∫≠t</option>
                </select></label>
            </div>
            <div class="button-container">
                <button onclick="randomStory()">Random Truy·ªán</button>
                <button onclick="filterStories()">L·ªçc Truy·ªán</button>
            </div>
        </div>

        <div id="saved-stories" class="table-section">
            <h3>Danh s√°ch truy·ªán ƒë√£ l∆∞u</h3>
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th onclick="sortTable(0, 'saved')">STT</th>
                            <th onclick="sortTable(1, 'saved')">T√™n truy·ªán</th>
                            <th onclick="sortTable(2, 'saved')">Tag</th>
                            <th>T√°c gi·∫£</th>
                            <th>Edit / Beta</th>
                            <th onclick="sortTable(3, 'saved')">T√¨nh tr·∫°ng</th>
                            <th>Link</th>
                            <th>Review</th>
                            <th>X√≥a</th>
                        </tr>
                    </thead>
                    <tbody id="storyTable"></tbody>
                </table>
            </div>
            <div class="pagination" id="pagination"></div>
        </div>

        <div id="downloaded-stories" class="table-section hidden">
            <h3>Danh s√°ch truy·ªán ƒë√£ t·∫£i</h3>
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th onclick="sortTable(0, 'downloaded')">STT</th>
                            <th onclick="sortTable(1, 'downloaded')">T√™n truy·ªán</th>
                            <th onclick="sortTable(2, 'downloaded')">Tag</th>
                            <th>T√°c gi·∫£</th>
                            <th>Edit / Beta</th>
                            <th onclick="sortTable(3, 'downloaded')">T√¨nh tr·∫°ng</th>
                            <th>Link</th>
                            <th>Review</th>
                            <th>X√≥a</th>
                        </tr>
                    </thead>
                    <tbody id="downloadedStoryTable"></tbody>
                </table>
            </div>
            <div class="pagination" id="downloadedPagination"></div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
        import { getFirestore, collection, addDoc, getDocs, query, where, deleteDoc, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBtpLSSNBj9lHtzibLh5QSRAPg3iQ46Q3g",
            authDomain: "tcct-minigames.firebaseapp.com",
            projectId: "tcct-minigames",
            storageBucket: "tcct-minigames.firebasestorage.app",
            messagingSenderId: "604780847536",
            appId: "1:604780847536:web:f8015bde5ef469b04c7675",
            measurementId: "G-1GGDZR6VY5"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const storiesCollection = collection(db, "stories");
        const downloadedStoriesCollection = collection(db, "downloaded_stories");

        const dbName = "StoryDB";
        let idb;

        function toggleSection(section) {
            document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
            document.getElementById(section).classList.add('active');
            document.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('btn-' + section).classList.add('active');
            
            document.querySelectorAll('.table-section').forEach(t => t.classList.add('hidden'));
            if (section === 'epub') {
                document.getElementById('downloaded-stories').classList.remove('hidden');
                loadDownloadedStories();
            } else {
                document.getElementById('saved-stories').classList.remove('hidden');
            }
        }

        function logMessage(msg) {
            const logBox = document.getElementById('log');
            logBox.value += msg + '\n';
            logBox.scrollTop = logBox.scrollHeight;
        }
		
		const apiBaseUrl = location.hostname.includes("localhost") 
		  ? "http://localhost:5000" 
		  : "https://tcct-game-hub-production.up.railway.app";

		async function handleEpubDownload() {
		  const url = document.querySelector('#epubUrl').value.trim();
		  const note = document.querySelector('#input-note')?.value.trim();
		  const isForumThread = url.includes('toanchuccaothu.com');

		  const log = (msg) => {
			const logBox = document.getElementById('log');
			logBox.value += msg + '\n';
			logBox.scrollTop = logBox.scrollHeight;
		  };

		  if (!url) return alert('Nh·∫≠p link ho·∫∑c n·ªôi dung!');

		  try {
			log(`üîç B·∫Øt ƒë·∫ßu x·ª≠ l√Ω...`);

			let title = note || 'Truy·ªán T·ª± ƒê·ªông';
			let chapters = [];

			if (isForumThread) {
			  log(`üß≤ ƒêang l·∫•y n·ªôi dung t·ª´ thread: ${url}`);
			  const res = await fetch(apiBaseUrl + '/api/crawl', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ url })
			  });
			  const data = await res.json();
			  if (!res.ok) throw data;
			  title = note || data.title;
			  chapters = data.chapters;
			} else {
			  const extraContent = document.getElementById('extra_content').value.trim();
			  if (!extraContent) return alert('N·ªôi dung r·ªóng!');
			  chapters = [{ title: 'Ch∆∞∆°ng 1', content: extraContent.replace(/\n/g, '<br>') }];
			}

			log(`üì¶ G·ª≠i y√™u c·∫ßu t·∫°o EPUB v·ªõi ${chapters.length} thread...`);

			const epubRes = await fetch(apiBaseUrl + '/api/epub', {
			  method: 'POST',
			  headers: { 'Content-Type': 'application/json' },
			  body: JSON.stringify({ title, chapters })
			});
			const epubData = await epubRes.json();
			if (!epubRes.ok) throw epubData;

			const { download_url } = epubData;
			log(`‚úÖ EPUB s·∫µn s√†ng: ${download_url}`);
			//window.open(apiBaseUrl + download_url, '_blank');
			const fileRes = await fetch(apiBaseUrl + download_url);
			const blob = await fileRes.blob();
			const tempUrl = URL.createObjectURL(blob);

			const a = document.createElement('a');
			a.href = tempUrl;
			a.download = download_url.split('/').pop();
			a.style.display = 'none';
			document.body.appendChild(a);
			a.click();
			URL.revokeObjectURL(tempUrl);
		  } catch (e) {
			console.error(e);
			alert(`L·ªói: ${e?.error || 'Kh√¥ng r√µ'}`);
		  }
		}
		window.handleEpubDownload = handleEpubDownload;

        function openDatabase() {
            let request = indexedDB.open(dbName, 2);
            request.onupgradeneeded = function (event) {
                idb = event.target.result;
                if (!idb.objectStoreNames.contains("stories")) {
                    idb.createObjectStore("stories", { keyPath: "url" });
                }
                if (!idb.objectStoreNames.contains("downloaded_stories")) {
                    idb.createObjectStore("downloaded_stories", { keyPath: "url" });
                }
            };
            request.onsuccess = function (event) {
                idb = event.target.result;
                loadStories();
                loadDownloadedStories();
            };
            request.onerror = function (event) {
                console.error("Database error:", event.target.error);
            };
        }

        async function fetchStory() {
            let inputField = document.getElementById("storyLink");
            let url = inputField.value.trim();
            inputField.value = url;

            if (!url) {
                alert("Vui l√≤ng nh·∫≠p link truy·ªán!");
                return;
            }

            const proxyUrl = "https://api.allorigins.win/raw?url=";
            let fetchUrl = proxyUrl + encodeURIComponent(url);

            try {
                let response = await fetch(fetchUrl);
                let text = await response.text();
                let parser = new DOMParser();
                let doc = parser.parseFromString(text, "text/html");

                let titleMatch = doc.querySelector("h1")?.innerText.match(/\[(.*?)\]\s*(\[.*?\])?(.*)/);
                let title = titleMatch ? titleMatch[3].trim() : "Kh√¥ng r√µ";
                let fullTitle = doc.querySelector("h1")?.innerText.trim() || "Kh√¥ng r√µ";

                let tagMatches = fullTitle.match(/\[(.*?)\]/g);
                let defaultTag = tagMatches ? tagMatches[tagMatches.length - 1].replace(/\[|\]/g, "") : "Kh√¥ng r√µ";

                let status = doc.querySelector("h1.p-title-value span")?.textContent.trim() || "Kh√¥ng r√µ";
                let author = "Kh√¥ng r√µ";
                let editor = "Kh√¥ng r√µ";

                doc.querySelectorAll("article.message-body.js-selectToQuote div").forEach(div => {
                    let text = div.innerText.trim();
                    let authorMatch = text.match(/T√°c gi·∫£:\s*(.+)|Author:\s*(.+)/i);
                    if (authorMatch) author = authorMatch[1] || authorMatch[2];

                    let editorMatch = text.match(/Editor:\s*(.+)|Edit:\s*(.+)|Edit\s*\+\s*beta:\s*(.+)/i);
                    if (editorMatch) editor = editorMatch[1] || editorMatch[2] || editorMatch[3];
                });

                editor = editor.replace(/^@/, "").trim();

                let story = {
                    title,
                    defaultTag,
                    userTags: [],
                    author,
                    editor,
                    status,
                    url,
                    review: {}
                };

                let existingStory = await fetchStoryFromFirestore(url);

                if (existingStory) {
                    story.userTags = existingStory.userTags || {};
                    story.review = existingStory.review || {};
                }

                displayStoryDetails(story);
                await saveStory(story);
            } catch (error) {
                console.error("L·ªói khi fetch truy·ªán:", error);
                alertqian("Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu t·ª´ link n√†y!");
            }
        }

        function removeVietnameseTones(str) {
            return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "")
                .replace(/ƒë/g, "d").replace(/ƒê/g, "D");
        }

        async function saveStoryToFirestore(story) {
            try {
                let storyId = removeVietnameseTones(story.title)
                    .replace(/[^\w\s]/gi, "")
                    .replace(/\s+/g, "_")
                    .trim();

                let storyRef = doc(storiesCollection, storyId);

                let existingDoc = await getDoc(storyRef);
                let existingData = existingDoc.exists() ? existingDoc.data() : {};

                let updatedStory = {
                    ...existingData,
                    ...story,
                    userTags: {
                        ...(existingData.userTags || {}),
                        ...(story.userTags || {})
                    }
                };

                await setDoc(storyRef, updatedStory, { merge: true });
            } catch (error) {
                console.error("L·ªói khi l∆∞u v√†o Firestore:", error);
            }
        }

        async function saveDownloadedStory(story) {
            try {
                let storyId = removeVietnameseTones(story.title)
                    .replace(/[^\w\s]/gi, "")
                    .replace(/\s+/g, "_")
                    .trim();

                let storyRef = doc(downloadedStoriesCollection, storyId);
                await setDoc(storyRef, story, { merge: true });
                saveStoryToIndexedDB(story, "downloaded_stories");
            } catch (error) {
                console.error("L·ªói khi l∆∞u downloaded story:", error);
            }
        }

        function saveStoryToIndexedDB(story, storeName = "stories") {
            if (!idb) {
                console.warn("IndexedDB ch∆∞a s·∫µn s√†ng.");
                return;
            }

            if (!story.url) {
                console.error("L·ªói: Kh√¥ng th·ªÉ l∆∞u truy·ªán v√†o IndexedDB v√¨ thi·∫øu 'url'!");
                return;
            }

            let transaction = idb.transaction([storeName], "readwrite");
            let store = transaction.objectStore(storeName);

            let getRequest = store.get(story.url);
            getRequest.onsuccess = function (event) {
                let existingStory = event.target.result || {};

                let updatedStory = {
                    ...existingStory,
                    ...story,
                    userTags: {
                        ...(existingStory.userTags || {}),
                        ...(story.userTags || {})
                    }
                };

                store.put(updatedStory);
            };

            getRequest.onerror = function (event) {
                console.error("L·ªói khi truy v·∫•n IndexedDB:", event.target.error);
            };
        }

        async function saveStory(story) {
            try {
                await saveStoryToFirestore(story);
                saveStoryToIndexedDB(story);
                await fetchTagsFromDatabase();
                loadStories();
            } catch (error) {
                console.error("L·ªói khi l∆∞u truy·ªán:", error);
            }
        }

        async function fetchStoryFromFirestore(url) {
            let querySnapshot = await getDocs(query(collection(db, "stories"), where("url", "==", url)));
            if (!querySnapshot.empty) {
                return querySnapshot.docs[0].data();
            }
            return null;
        }

        function displayStoryDetails(story) {
            let allTags = [story.defaultTag];

            if (story.userTags && typeof story.userTags === "object") {
                Object.values(story.userTags).forEach(tagList => {
                    tagList.forEach(tag => allTags.push(tag));
                });
            }

            document.getElementById("additionalTags").value = allTags.join(", ");

            let allReviews = [];
            if (story.review && typeof story.review === "object") {
                Object.entries(story.review).forEach(([username, reviews]) => {
                    allReviews.push(`${username}: ${reviews.join(", ")}`);
                });
            }

            document.getElementById("reviewText").value = allReviews.join(" | ");
        }

        async function loadStories() {
            let indexedDBStories = await loadStoriesFromIndexedDB("stories");
            let storyMap = {};

            indexedDBStories.forEach(story => {
                storyMap[story.url] = story;
            });

            renderStories(indexedDBStories, "storyTable");

            try {
                let firestoreStories = await getDocs(storiesCollection);
                let stories = [];

                firestoreStories.forEach((doc) => {
                    let story = doc.data();
                    story.id = doc.id;

                    if (storyMap[story.url]) {
                        story.userTags = {
                            ...(storyMap[story.url].userTags || {}),
                            ...(story.userTags || {})
                        };
                    }

                    stories.push(story);
                    saveStoryToIndexedDB(story);
                });

                renderStories(stories, "storyTable");
            } catch (error) {
                console.error("L·ªói khi t·∫£i truy·ªán t·ª´ Firestore:", error);
            }
        }

        async function loadDownloadedStories() {
            let indexedDBStories = await loadStoriesFromIndexedDB("downloaded_stories");
            let storyMap = {};

            indexedDBStories.forEach(story => {
                storyMap[story.url] = story;
            });

            renderStories(indexedDBStories, "downloadedStoryTable");

            try {
                let firestoreStories = await getDocs(downloadedStoriesCollection);
                let stories = [];

                firestoreStories.forEach((doc) => {
                    let story = doc.data();
                    story.id = doc.id;

                    if (storyMap[story.url]) {
                        story.userTags = {
                            ...(storyMap[story.url].userTags || {}),
                            ...(story.userTags || {})
                        };
                    }

                    stories.push(story);
                    saveStoryToIndexedDB(story, "downloaded_stories");
                });

                renderStories(stories, "downloadedStoryTable");
            } catch (error) {
                console.error("L·ªói khi t·∫£i downloaded stories:", error);
            }
        }

        function loadStoriesFromIndexedDB(storeName) {
            return new Promise((resolve, reject) => {
                if (!idb) {
                    resolve([]);
                    return;
                }

                let transaction = idb.transaction([storeName], "readonly");
                let store = transaction.objectStore(storeName);
                let request = store.getAll();

                request.onsuccess = function (event) {
                    resolve(event.target.result);
                };

                request.onerror = function (event) {
                    console.error("L·ªói khi t·∫£i t·ª´ IndexedDB:", event.target.error);
                    resolve([]);
                };
            });
        }

        async function deleteStoryFromFirestore(storyId, collectionName = "stories") {
            await deleteDoc(doc(db, collectionName, storyId));
        }

        function deleteStoryFromIndexedDB(storyUrl, storeName = "stories") {
            let transaction = idb.transaction([storeName], "readwrite");
            let store = transaction.objectStore(storeName);
            store.delete(storyUrl);
        }

        function deleteStory(storyUrl, storyId, collectionName = "stories", tableId = "storyTable") {
            deleteStoryFromIndexedDB(storyUrl, collectionName === "stories" ? "stories" : "downloaded_stories");
            if (storyId) {
                deleteStoryFromFirestore(storyId, collectionName);
            }
            setTimeout(() => {
                if (collectionName === "stories") {
                    loadStories();
                } else {
                    loadDownloadedStories();
                }
            }, 500);
        }

        let allTags = [];

        async function fetchTagsFromDatabase() {
            try {
                let querySnapshot = await getDocs(collection(db, "stories"));
                allTags = new Set();

                querySnapshot.forEach(doc => {
                    let storyData = doc.data();
                    if (storyData.defaultTag) allTags.add(storyData.defaultTag);
                    if (storyData.userTags && typeof storyData.userTags === "object") {
                        Object.values(storyData.userTags).forEach(tag => allTags.add(tag));
                    }
                });

                allTags = [...allTags];
            } catch (error) {
                console.error("L·ªói khi t·∫£i tag:", error);
            }
        }

        async function loadAllTags() {
            let allTagsSet = new Set();
            let querySnapshot = await getDocs(collection(db, "stories"));

            querySnapshot.forEach(doc => {
                let story = doc.data();
                if (story.defaultTag) {
                    allTagsSet.add(story.defaultTag);
                }
                if (story.userTags && typeof story.userTags === "object") {
                    Object.values(story.userTags).forEach(userTagList => {
                        userTagList.forEach(tag => allTagsSet.add(tag));
                    });
                }
            });

            window.allTags = Array.from(allTagsSet);
        }

        function suggestTags(event) {
            let input = event.target;
            let inputValue = input.value.trim().toLowerCase();
            let suggestionsBox = document.getElementById("tagSuggestions");

            if (!inputValue) {
                suggestionsBox.style.display = "none";
                return;
            }

            let filteredTags = window.allTags.filter(tag => {
                let words = tag.toLowerCase().split(" ");
                return words.some(word => word.startsWith(inputValue));
            });

            if (filteredTags.length === 0) {
                suggestionsBox.style.display = "none";
                return;
            }

            suggestionsBox.innerHTML = "";
            filteredTags.forEach(tag => {
                let suggestion = document.createElement("div");
                suggestion.textContent = tag;
                suggestion.classList.add("suggestion-item");
                suggestion.onclick = () => selectTag(tag);
                suggestionsBox.appendChild(suggestion);
            });

            suggestionsBox.style.display = "block";
        }

        function selectTag(tag) {
            let inputField = document.getElementById("additionalTags");
            let existingTags = inputField.value.split(",").map(t => t.trim());

            if (!existingTags.includes(tag)) {
                existingTags.push(tag);
            }

            inputField.value = existingTags.join(", ");
            document.getElementById("tagSuggestions").style.display = "none";
        }

        document.getElementById("additionalTags").addEventListener("input", async function(event) {
            let input = event.target;
            let value = input.value.trim();

            if (value.endsWith(",")) {
                let tag = value.slice(0, -1).trim();

                if (!tag) return;

                let storyURL = document.getElementById("storyLink").value.trim();
                if (!storyURL) {
                    alert("B·∫°n c·∫ßn nh·∫≠p link truy·ªán tr∆∞·ªõc khi th√™m tag.");
                    return;
                }

                let querySnapshot = await getDocs(query(collection(db, "stories"), where("url", "==", storyURL)));

                if (querySnapshot.empty) {
                    alert("Truy·ªán n√†y ch∆∞a ƒë∆∞·ª£c l∆∞u, kh√¥ng th·ªÉ th√™m tag.");
                    return;
                }

                let storyDoc = querySnapshot.docs[0];
                let storyId = storyDoc.id;

                let username = localStorage.getItem("username") || "Guest";
                let storyRef = doc(db, "stories", storyId);
                let storyData = storyDoc.data();

                let existingTags = storyData.userTags || {};
                existingTags[username] = existingTags[username] ? [...existingTags[username], tag] : [tag];

                await setDoc(storyRef, { userTags: existingTags }, { merge: true });
            }
        });

        document.getElementById("reviewText").addEventListener("input", async function(event) {
            let input = event.target;
            let value = input.value.trim();

            if (value.endsWith(".")) {
                let review = value.slice(0, -1).trim();

                if (!review) return;

                let storyURL = document.getElementById("storyLink").value.trim();
                if (!storyURL) {
                    alert("B·∫°n c·∫ßn nh·∫≠p link truy·ªán tr∆∞·ªõc khi th√™m review.");
                    return;
                }

                let querySnapshot = await getDocs(query(collection(db, "stories"), where("url", "==", storyURL)));

                if (querySnapshot.empty) {
                    alert("Truy·ªán n√†y ch∆∞a ƒë∆∞·ª£c l∆∞u, kh√¥ng th·ªÉ th√™m review.");
                    return;
                }

                let storyDoc = querySnapshot.docs[0];
                let storyId = storyDoc.id;

                let username = localStorage.getItem("username") || "Guest";
                let storyRef = doc(db, "stories", storyId);
                let storyData = storyDoc.data();

                let existingReviews = storyData.review || {};
                existingReviews[username] = existingReviews[username] ? [...existingReviews[username], review] : [review];

                await setDoc(storyRef, { review: existingReviews }, { merge: true });
            }
        });

        function renderStories(stories, tableId) {
            let storyTable = document.getElementById(tableId);
            storyTable.innerHTML = "";

            stories.forEach((story, index) => {
                let allTags = story.defaultTag || "Kh√¥ng c√≥ tag";

                if (story.userTags && typeof story.userTags === "object") {
                    let userTagList = Object.entries(story.userTags)
                        .map(([_, tag]) => tag)
                        .join(", ");

                    if (userTagList) {
                        allTags += `, ${userTagList}`;
                    }
                }

                let collectionName = tableId === "storyTable" ? "stories" : "downloaded_stories";
                let row = `
                    <tr>
                        <td>${index + 1}</td>
                        <td>${story.title}</td>
                        <td>${allTags}</td>
                        <td>${story.author}</td>
                        <td>${story.editor}</td>
                        <td>${story.status}</td>
                        <td><a href="${story.url}" target="_blank">Xem</a></td>
                        <td contenteditable="true" onblur="updateReview('${story.url}', this.innerText, '${collectionName}')">
                            ${story.review ? Object.values(story.review || {}).join(", ") : ""}
                        </td>
                        <td class="delete-btn" onclick="deleteStory('${story.url}', '${story.id || ""}', '${collectionName}', '${tableId}')">üóë</td>
                    </tr>
                `;
                storyTable.innerHTML += row;
            });
        }

        async function updateReview(storyUrl, reviewText, collectionName = "stories") {
            let querySnapshot = await getDocs(query(collection(db, collectionName), where("url", "==", storyUrl)));
            if (querySnapshot.empty) return;

            let storyDoc = querySnapshot.docs[0];
            let storyId = storyDoc.id;
            let username = localStorage.getItem("username") || "Guest";

            let storyRef = doc(db, collectionName, storyId);
            let storyData = storyDoc.data();

            let existingReviews = storyData.review || {};
            existingReviews[username] = [reviewText];

            await setDoc(storyRef, { review: existingReviews }, { merge: true });
        }

        async function filterStories() {
            let desiredTags = document.getElementById("desiredTags").value.split(",").map(t => t.trim()).filter(t => t);
            let excludedTags = document.getElementById("excludedTags").value.split(",").map(t => t.trim()).filter(t => t);
            let author = document.getElementById("authorSelect").value;
            let editor = document.getElementById("editorSelect").value;
            let status = document.getElementById("statusSelect").value;

            let q = query(collection(db, "stories"));
            let stories = [];

            let querySnapshot = await getDocs(q);
            querySnapshot.forEach(doc => {
                let story = doc.data();
                story.id = doc.id;

                let tags = [story.defaultTag, ...(story.userTags ? Object.values(story.userTags).flat() : [])];
                let include = true;

                if (desiredTags.length > 0 && !desiredTags.every(tag => tags.includes(tag))) {
                    include = false;
                }
                if (excludedTags.length > 0 && excludedTags.some(tag => tags.includes(tag))) {
                    include = false;
                }
                if (author && story.author !== author) {
                    include = false;
                }
                if (editor && story.editor !== editor) {
                    include = false;
                }
                if (status && story.status !== status) {
                    include = false;
                }

                if (include) {
                    stories.push(story);
                }
            });

            renderStories(stories, "storyTable");
        }

        async function randomStory() {
            let querySnapshot = await getDocs(collection(db, "stories"));
            let stories = [];

            querySnapshot.forEach(doc => {
                let story = doc.data();
                story.id = doc.id;
                stories.push(story);
            });

            if (stories.length > 0) {
                let randomIndex = Math.floor(Math.random() * stories.length);
                renderStories([stories[randomIndex]], "storyTable");
            }
        }

		function autoFillLofterLinks() {
			const url = window.location.href;
			if (!url.includes('.lofter.com')) return;
			const postLinks = Array.from(document.querySelectorAll('a[href*=".lofter.com/post/"]')).map(a => a.href);
			const uniqueLinks = [...new Set(postLinks)];
			if (uniqueLinks.length > 0) {
				console.log(`Auto-fill ${uniqueLinks.length} links t·ª´ trang t√°c gi·∫£.`);
				document.getElementById('epubUrl').value = uniqueLinks.join('\n');
			}
		}


		async function handleEpubDownloadAuto() {
			const urlInput = document.querySelector('#epubUrl').value.trim();
			const note = document.querySelector('#input-note')?.value?.trim();
			const log = (msg) => {
				const logBox = document.getElementById('log');
				logBox.value += msg + '';
				logBox.scrollTop = logBox.scrollHeight;
			};

			if (!urlInput) return alert('Nh·∫≠p link ho·∫∑c n·ªôi dung!');

			const urlList = urlInput.split('\n').map(u => u.trim()).filter(u => u);
			const isForumThread = urlList.length === 1 && urlList[0].includes('toanchuccaothu.com');

			try {
				if (isForumThread) {
					log(`üß≤ ƒêang l·∫•y n·ªôi dung t·ª´ thread: ${urlList[0]}`);
					const res = await fetch(apiBaseUrl + '/api/crawl', {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({ url: urlList[0] })
					});
					const data = await res.json();
					if (!res.ok) throw data;
					const title = note || data.title;
					const chapters = data.chapters;
					log(`üì¶ G·ª≠i y√™u c·∫ßu t·∫°o EPUB v·ªõi ${chapters.length} thread...`);
					const epubRes = await fetch(apiBaseUrl + '/api/epub', {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({ title, chapters })
					});
					const epubData = await epubRes.json();
					if (!epubRes.ok) throw epubData;
					const { download_url } = epubData;
					log(`‚úÖ EPUB s·∫µn s√†ng: ${download_url}`);
					const fileRes = await fetch(apiBaseUrl + download_url);
					const blob = await fileRes.blob();
					const tempUrl = URL.createObjectURL(blob);
					const a = document.createElement('a');
					a.href = tempUrl;
					a.download = download_url.split('/').pop();
					a.style.display = 'none';
					document.body.appendChild(a);
					a.click();
					URL.revokeObjectURL(tempUrl);
					return;
				}

				if (urlList.length === 1 && document.getElementById('extra_content').value.trim()) {
					const extraContent = document.getElementById('extra_content').value.trim();
					const chapters = [{ title: 'Ch∆∞∆°ng 1', content: extraContent.replace(/\n/g, '<br>') }];
					const epubRes = await fetch(apiBaseUrl + '/api/epub', {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({ title: note || 'Truy·ªán T·ª± ƒê·ªông', chapters })
					});
					const epubData = await epubRes.json();
					if (!epubRes.ok) throw epubData;
					const { download_url } = epubData;
					log(`‚úÖ EPUB s·∫µn s√†ng: ${download_url}`);
					const fileRes = await fetch(apiBaseUrl + download_url);
					const blob = await fileRes.blob();
					const tempUrl = URL.createObjectURL(blob);
					const a = document.createElement('a');
					a.href = tempUrl;
					a.download = download_url.split('/').pop();
					a.style.display = 'none';
					document.body.appendChild(a);
					a.click();
					URL.revokeObjectURL(tempUrl);
					return;
				}

				log(`üîç B·∫Øt ƒë·∫ßu x·ª≠ l√Ω multi-link (${urlList.length} link)...`);
				const crawlRes = await fetch(apiBaseUrl + '/api/crawl_multi', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ urls: urlList })
				});
				const crawlData = await crawlRes.json();
				if (!crawlRes.ok) throw crawlData;
				log(`üì¶ G·ª≠i y√™u c·∫ßu t·∫°o EPUB v·ªõi ${crawlData.chapters.length} b√†i...`);
				const epubRes = await fetch(apiBaseUrl + '/api/epub', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ title: crawlData.title, chapters: crawlData.chapters })
				});
				const epubData = await epubRes.json();
				if (!epubRes.ok) throw epubData;
				const { download_url } = epubData;
				log(`‚úÖ EPUB s·∫µn s√†ng: ${download_url}`);
				const fileRes = await fetch(apiBaseUrl + download_url);
				const blob = await fileRes.blob();
				const tempUrl = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = tempUrl;
				a.download = download_url.split('/').pop();
				a.style.display = 'none';
				document.body.appendChild(a);
				a.click();
				URL.revokeObjectURL(tempUrl);
			} catch (e) {
				console.error(e);
				alert(`L·ªói: ${e?.error || 'Kh√¥ng r√µ'}`);
			}
		}


        async function populateSelectOptions() {
            let authors = new Set();
            let editors = new Set();
            let querySnapshot = await getDocs(collection(db, "stories"));

            querySnapshot.forEach(doc => {
                let story = doc.data();
                if (story.author) authors.add(story.author);
                if (story.editor) editors.add(story.editor);
            });

            let authorSelect = document.getElementById("authorSelect");
            let editorSelect = document.getElementById("editorSelect");

            authorSelect.innerHTML = '<option value="">T·∫•t c·∫£</option>';
            editorSelect.innerHTML = '<option value="">T·∫•t c·∫£</option>';

            authors.forEach(author => {
                authorSelect.innerHTML += `<option value="${author}">${author}</option>`;
            });
            editors.forEach(editor => {
                editorSelect.innerHTML += `<option value="${editor}">${editor}</option>`;
            });
        }

        function sortTable(columnIndex, tableType) {
            let tableId = tableType === 'saved' ? "storyTable" : "downloadedStoryTable";
            let table = document.getElementById(tableId);
            let rows = Array.from(table.rows);
            let isAscending = table.dataset.sortOrder !== "asc";
            table.dataset.sortOrder = isAscending ? "asc" : "desc";

            rows.sort((a, b) => {
                let aValue = a.cells[columnIndex].innerText;
                let bValue = b.cells[columnIndex].innerText;

                if (columnIndex === 0) {
                    aValue = parseInt(aValue) || 0;
                    bValue = parseInt(bValue) || 0;
                }

                if (aValue < bValue) return isAscending ? -1 : 1;
                if (aValue > bValue) return isAscending ? 1 : -1;
                return 0;
            });

            table.innerHTML = "";
            rows.forEach(row => table.appendChild(row));
        }

        document.getElementById("additionalTags").addEventListener("input", suggestTags);
        document.addEventListener("click", function(event) {
            if (!event.target.closest("#additionalTags") && !event.target.closest("#tagSuggestions")) {
                document.getElementById("tagSuggestions").style.display = "none";
            }
        });

        openDatabase();
        fetchTagsFromDatabase();
        loadAllTags();
        populateSelectOptions();

        window.toggleSection = toggleSection;
        window.fetchStory = fetchStory;
        window.deleteStory = deleteStory;
        window.suggestTags = suggestTags;
        window.renderStories = renderStories;
        window.saveStory = saveStory;
        window.filterStories = filterStories;
        window.randomStory = randomStory;
        window.updateReview = updateReview;
    </script>
</body>
</html>